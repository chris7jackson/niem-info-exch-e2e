name: PR Quality Checks

on:
  pull_request:
    branches: [main, develop]
    paths:
      - 'api/**'
      - 'ui/**'
      - '.github/workflows/**'
  workflow_dispatch:  # Manual trigger for testing

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '18'

jobs:
  # =============================================================================
  # DETECT CHANGED FILES
  # =============================================================================

  detect-changes:
    name: Detect Changed Files
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      ui: ${{ steps.filter.outputs.ui }}
      workflows: ${{ steps.filter.outputs.workflows }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check changed files
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            api:
              - 'api/**'
            ui:
              - 'ui/**'
            workflows:
              - '.github/workflows/**'

  # =============================================================================
  # BACKEND QUALITY CHECKS
  # =============================================================================

  backend-quality:
    name: Backend Quality (Lint, Type, Unit Tests)
    runs-on: ubuntu-latest
    needs: [detect-changes]

    # Only run if API files or workflows changed
    if: |
      github.event_name == 'workflow_dispatch' ||
      needs.detect-changes.outputs.api == 'true' ||
      needs.detect-changes.outputs.workflows == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: 'api/requirements*.txt'

      - name: Install dependencies
        run: |
          cd api
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-test.txt
          # Install package in editable mode for tests
          pip install -e .

      - name: Run Ruff linter
        run: |
          cd api
          # TODO: Make blocking after fixing Ruff errors (tracked in issue)
          ruff check src/ --output-format=github || echo "⚠️ Ruff has errors - see output above"

      - name: Run Black formatter check
        run: |
          cd api
          # TODO: Make blocking after formatting all files (tracked in issue)
          black src/ --check --diff || echo "⚠️ Black formatting issues found - 30 files need reformatting"

      - name: Run MyPy type checking
        run: |
          cd api
          # TODO: Make blocking after fixing MyPy errors (tracked in issue)
          mypy src/ || echo "⚠️ MyPy found 174 type checking errors - see output above"

      - name: Run Bandit security check (high+ severity)
        run: |
          cd api
          bandit -r src/ -ll -f json -o bandit-report.json || true
          # Fail on high/critical security issues
          bandit -r src/ -ll

      - name: Run unit tests with coverage
        run: |
          cd api
          # Generate coverage report (without failing on overall coverage)
          pytest tests/unit/ \
            --cov=src \
            --cov-report=term-missing \
            --cov-report=xml:coverage.xml \
            --cov-report=html:htmlcov \
            --junit-xml=pytest-report.xml

      - name: Check coverage on changed code only
        if: github.event_name == 'pull_request'
        run: |
          cd api
          # Install diff-cover to check only new/changed lines
          pip install diff-cover

          # Fetch base branch for comparison
          git fetch origin ${{ github.base_ref }}

          # Check that new code has 80%+ coverage (ignores old tech debt)
          diff-cover coverage.xml \
            --compare-branch=origin/${{ github.base_ref }} \
            --fail-under=80 \
            --html-report=diff-coverage.html

          echo "✅ New code meets 80% coverage requirement"

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-coverage
          path: |
            api/coverage.xml
            api/htmlcov/
            api/diff-coverage.html

      - name: Upload security report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-security
          path: api/bandit-report.json

  # =============================================================================
  # API INTEGRATION TESTS
  # =============================================================================

  api-integration-tests:
    name: API Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-changes]

    # Only run if API files or workflows changed
    if: |
      github.event_name == 'workflow_dispatch' ||
      needs.detect-changes.outputs.api == 'true' ||
      needs.detect-changes.outputs.workflows == 'true'

    services:
      neo4j:
        image: neo4j:5.20.0-community
        env:
          NEO4J_AUTH: neo4j/testpassword
          NEO4J_PLUGINS: '["apoc"]'
        options: >-
          --health-cmd "cypher-shell -u neo4j -p testpassword 'RETURN 1'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 7687:7687
          - 7474:7474

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start MinIO
        run: |
          docker run -d \
            --name minio \
            -p 9000:9000 \
            -p 9001:9001 \
            -e MINIO_ROOT_USER=minioadmin \
            -e MINIO_ROOT_PASSWORD=minioadmin \
            minio/minio:latest \
            server /data --console-address ":9001"

          # Wait for MinIO to be ready
          timeout 60 bash -c 'until curl -f http://localhost:9000/minio/health/live 2>/dev/null; do sleep 2; done'
          echo "✅ MinIO is ready"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: 'api/requirements*.txt'

      - name: Install dependencies
        run: |
          cd api
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-test.txt
          # Install package in editable mode for tests
          pip install -e .

      - name: Run integration tests
        env:
          NEO4J_URI: bolt://localhost:7687
          NEO4J_USER: neo4j
          NEO4J_PASSWORD: testpassword
          MINIO_ENDPOINT: localhost:9000
          MINIO_ACCESS_KEY: minioadmin
          MINIO_SECRET_KEY: minioadmin
          MINIO_SECURE: false
        run: |
          cd api
          pytest tests/integration/ \
            --verbose \
            --junit-xml=integration-report.xml

      - name: Upload integration test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: api/integration-report.xml

  # =============================================================================
  # COMMIT MESSAGE VALIDATION
  # =============================================================================

  commit-validation:
    name: Validate Conventional Commits
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate commit messages
        run: |
          # Get all commits in this PR
          COMMITS=$(git log origin/${{ github.base_ref }}..HEAD --pretty=format:"%s")

          echo "Validating commit messages..."
          INVALID_COUNT=0

          while IFS= read -r commit_msg; do
            # Skip merge commits
            if echo "$commit_msg" | grep -qE '^Merge (pull request|branch)'; then
              echo "⏭️  Skipping merge commit: $commit_msg"
              continue
            fi

            # Check if commit follows conventional commit format
            if ! echo "$commit_msg" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|chore|build|ci|revert)(\(.+\))?(!)?:.+'; then
              echo "⚠️  Invalid commit message: $commit_msg"
              echo "   Expected format: type(scope): description"
              echo "   Valid types: feat, fix, docs, style, refactor, perf, test, chore, build, ci, revert"
              INVALID_COUNT=$((INVALID_COUNT + 1))
            else
              echo "✅ Valid: $commit_msg"
            fi
          done <<< "$COMMITS"

          if [ $INVALID_COUNT -gt 0 ]; then
            echo ""
            echo "⚠️  Found $INVALID_COUNT invalid commit message(s)"
            echo "Please follow conventional commit format: https://www.conventionalcommits.org/"
            echo "This is a warning - PR will not be blocked"
          else
            echo ""
            echo "✅ All commit messages are valid!"
          fi

  # =============================================================================
  # DEPENDENCY SECURITY REVIEW
  # =============================================================================

  dependency-review:
    name: Dependency Security Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Dependency Review
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
          deny-licenses: GPL-3.0, AGPL-3.0
          comment-summary-in-pr: on-failure

  # =============================================================================
  # FRONTEND QUALITY CHECKS
  # =============================================================================

  frontend-quality:
    name: Frontend Quality (Lint, Type, Unit Tests)
    runs-on: ubuntu-latest
    needs: [detect-changes]

    # Only run if UI files or workflows changed
    if: |
      github.event_name == 'workflow_dispatch' ||
      needs.detect-changes.outputs.ui == 'true' ||
      needs.detect-changes.outputs.workflows == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          # Disable npm cache due to Rollup optional dependency bug
          # cache: 'npm'
          # cache-dependency-path: ui/package-lock.json

      - name: Install dependencies
        run: |
          cd ui
          # Handle npm bug with optional dependencies (Rollup)
          # https://github.com/npm/cli/issues/4828
          # Remove both package-lock.json and node_modules for clean install
          rm -f package-lock.json
          rm -rf node_modules
          npm install --no-audit

      - name: Run ESLint
        run: |
          cd ui
          # TODO: Make blocking after fixing ESLint errors (tracked in issue)
          npm run lint || echo "⚠️ ESLint has errors - see GitHub issue for tracking"

      - name: Run Prettier format check
        run: |
          cd ui
          npm run format:check

      - name: Run TypeScript type checking
        run: |
          cd ui
          npm run type-check

      - name: Run npm audit (critical/high vulnerabilities)
        run: |
          cd ui
          npm audit --audit-level=high --json > npm-audit.json || true
          # Fail on critical/high vulnerabilities
          npm audit --audit-level=high

      - name: Run unit tests
        run: |
          cd ui
          # Run tests without strict coverage requirements (thin wrappers over libraries)
          npm run test:run

      - name: Check build
        run: |
          cd ui
          npm run build

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-coverage
          path: ui/coverage/

      - name: Upload security report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-security
          path: ui/npm-audit.json

  # =============================================================================
  # DOCKER BUILD & SMOKE TESTS
  # =============================================================================

  docker-smoke-tests:
    name: Docker Build & Smoke Tests
    runs-on: ubuntu-latest
    needs: [detect-changes, backend-quality, frontend-quality]
    # Always run (validates full Docker build works for all PRs)
    if: |
      always() &&
      (needs.backend-quality.result == 'success' || needs.backend-quality.result == 'skipped') &&
      (needs.frontend-quality.result == 'success' || needs.frontend-quality.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read version files
        id: version
        run: |
          API_VERSION=$(cat api/VERSION)
          UI_VERSION=$(cat ui/VERSION)
          echo "api_version=$API_VERSION" >> $GITHUB_OUTPUT
          echo "ui_version=$UI_VERSION" >> $GITHUB_OUTPUT
          echo "API version: $API_VERSION"
          echo "UI version: $UI_VERSION"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and start services
        env:
          API_VERSION: ${{ steps.version.outputs.api_version }}
          UI_VERSION: ${{ steps.version.outputs.ui_version }}
          GIT_COMMIT: ${{ github.sha }}
          BUILD_DATE: ${{ github.event.pull_request.updated_at }}
        run: |
          # Build API with version metadata
          docker compose build --build-arg VERSION=${API_VERSION} \
            --build-arg GIT_COMMIT=${GIT_COMMIT} \
            --build-arg BUILD_DATE=${BUILD_DATE} \
            api

          # Build UI with version metadata
          docker compose build --build-arg VERSION=${UI_VERSION} \
            --build-arg GIT_COMMIT=${GIT_COMMIT} \
            --build-arg BUILD_DATE=${BUILD_DATE} \
            ui

          # Start all services
          docker compose up -d

      - name: Wait for services to be ready
        run: |
          timeout 120 bash -c 'until curl -f http://localhost:8000/healthz; do sleep 5; done'
          timeout 120 bash -c 'until curl -f http://localhost:3000; do sleep 5; done'
          echo "All services are healthy"

      - name: Run smoke tests
        run: |
          # Test API health endpoints
          echo "Testing API healthz..."
          API_RESPONSE=$(curl -f http://localhost:8000/healthz)
          echo "$API_RESPONSE"

          # Verify API version is injected
          API_VERSION=$(echo "$API_RESPONSE" | jq -r '.api_version')
          echo "API version from /healthz: $API_VERSION"
          if [ "$API_VERSION" == "unknown" ] || [ "$API_VERSION" == "null" ]; then
            echo "❌ API version not properly injected!"
            exit 1
          fi

          echo "Testing API readyz..."
          curl -f http://localhost:8000/readyz

          # Test UI is accessible
          echo "Testing UI..."
          curl -f http://localhost:3000

          echo "✅ All smoke tests passed"

      - name: View service logs on failure
        if: failure()
        run: |
          echo "=== API Logs ==="
          docker compose logs api
          echo "=== UI Logs ==="
          docker compose logs ui
          echo "=== Neo4j Logs ==="
          docker compose logs neo4j
          echo "=== MinIO Logs ==="
          docker compose logs minio

      - name: Stop services
        if: always()
        run: docker compose down

  # =============================================================================
  # OVERALL STATUS CHECK
  # =============================================================================

  pr-status:
    name: PR Quality Status
    runs-on: ubuntu-latest
    needs: [backend-quality, frontend-quality, api-integration-tests, docker-smoke-tests, commit-validation, dependency-review]
    if: always()

    steps:
      - name: Check all quality gates passed
        run: |
          backend_result="${{ needs.backend-quality.result }}"
          frontend_result="${{ needs.frontend-quality.result }}"
          integration_result="${{ needs.api-integration-tests.result }}"
          smoke_result="${{ needs.docker-smoke-tests.result }}"
          commit_result="${{ needs.commit-validation.result }}"
          dependency_result="${{ needs.dependency-review.result }}"

          echo "=== PR Quality Gate Results ==="
          echo "Backend Quality: $backend_result"
          echo "Frontend Quality: $frontend_result"
          echo "API Integration Tests: $integration_result"
          echo "Docker Smoke Tests: $smoke_result"
          echo "Commit Validation: $commit_result (non-blocking)"
          echo "Dependency Review: $dependency_result"
          echo ""

          # Allow skipped jobs (when files didn't change or workflow_dispatch)
          # Commit validation is informational only - not blocking
          if [[ "$backend_result" == "success" || "$backend_result" == "skipped" ]] && \
             [[ "$frontend_result" == "success" || "$frontend_result" == "skipped" ]] && \
             [[ "$integration_result" == "success" || "$integration_result" == "skipped" ]] && \
             [[ "$smoke_result" == "success" || "$smoke_result" == "skipped" ]] && \
             [[ "$dependency_result" == "success" || "$dependency_result" == "skipped" ]]; then
            echo "✅ All quality gates passed!"
            exit 0
          else
            echo "❌ One or more quality gates failed!"
            exit 1
          fi
